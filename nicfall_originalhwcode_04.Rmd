---
title: "nicfall_originalhwcode_04"
author: "Nicola Kriefall"
date: "10/24/2019"
output: html_document
---

HW 4, instructions [here](https://fuzzyatelin.github.io/bioanth-stats/homework-04.html)

[1] Write a simple R function, Z.prop.test(), that can perform one- or two-sample Z-tests for proportion data, using the following guidelines:

Your function should take the following arguments: p1 and n1 (no default) representing the estimated proportion and sample size (i.e., based on your sample data); p2 and n2 (both defaulting to NULL) that contain a second sample’s proportion and sample size data in the event of a two-sample test; p0 (no default) as the expected value for the population proportion; and alternative (default “two.sided”) and conf.level (default 0.95), to be used in the same way as in the function t.test().

When conducting a two-sample test, it should be p1 that is tested as being smaller or larger than p2 when alternative=“less” or alternative=“greater”, the same as in the use of x and y in the function t.test().

The function should perform a one-sample Z-test using p1, n1, and p0 if either p2 or n2 (or both) is NULL.

The function should contain a check for the rules of thumb we have talked about (n∗p>5 and n∗(1−p)>5) to ensure the validity of assuming the normal distribution in both the one- and two-sample settings. If this is violated, the function should still complete but it should also print an appropriate warning message.

The function should return a list containing the members Z (the test statistic), P (the appropriate p value), and CI (the two-sided CI with respect to “conf.level” around p1 in the case of a one-sample test and around p2-p1 in the case of a two-sample test). For all test alternatives (“two.sided”, “greater”, “less”), calculate symmetric CIs based on quantiles of the normal distribution rather than worrying about calculating single-limit confidence bounds.

```{r}
Z.prop.test <- function(p0, p1, n1, p2 = NULL, n2 = NULL, alternative="two.sided", conf.level=0.95){
  if(is.null(p2) && is.null(n2)){
    if(n1*p0 <= 5){print("Warning: assumption of normality (n1*p0 > 5) violated")}
    if(n1*(1-p0) <= 5){print("Warning: assumption of normality (n1*(1-p0)) violated")}
    if(n1*p1 <= 5){print("Warning: assumption of normality (n1*p1 > 5) violated")}
    if(n1*(1-p1) <= 5){print("Warning: assumption of normality (n1*(1-p1)) violated")}
    if(alternative=="two.sided"){
     x2 <- NULL
     m1 <- p1 # mean, observed
     z1 <- (m1 - p0)/sqrt(p0 * (1 - p0)/n1)
     pv1 <- 1 - pnorm(z1,lower.tail=TRUE) + pnorm(z1,lower.tail=FALSE)
     perc <- (1-((1-conf.level)/2))
     lower <- p1 - qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     upper <- p1 + qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     ci <- c(lower, upper)
     print(c("z-statistic:",z1))
     print(c("p-value:",pv1))
     print(c("ci (lower,upper):",ci))
    }
    if(alternative=="less"){
     x2 <- NULL
     m1 <- p1 # mean, observed
     z1 <- (m1 - p0)/sqrt(p0 * (1 - p0)/n1)
     pv1 <- pnorm(z1, lower.tail = TRUE)
     perc <- (1-((1-conf.level)/2))
     lower <- p1 - qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     upper <- p1 + qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     ci <- c(lower, upper)
     print(c("z-statistic:",z1))
     print(c("p-value:",pv1))
     print(c("ci (lower,upper):",ci))
    }
    if(alternative=="greater"){
     x2 <- NULL
     m1 <- p1 # mean, observed
     z1 <- (m1 - p0)/sqrt(p0 * (1 - p0)/n1)
     pv1 <- pnorm(z1, lower.tail = FALSE)
     perc <- (1-((1-conf.level)/2))
     lower <- p1 - qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     upper <- p1 + qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     ci <- c(lower, upper)
     print(c("z-statistic:",z1))
     print(c("p-value:",pv1))
     print(c("ci (lower,upper):",ci))
    }
    }
  else{
    p0 <- 0
    if(n1*p1 <= 5){print("Warning: assumption of normality (n1*p1 > 5) violated")}
    if(n1*(1-p1) <= 5){print("Warning: assumption of normality (n1*(1-p1)) violated")}
    if(n2*p2 <= 5){print("Warning: assumption of normality (n2*p2 > 5) violated")}
    if(n2*(1-p2) <= 5){print("Warning: assumption of normality (n2*(1-p2)) violated")}
    if(alternative=="two.sided"){
     x2 <- NULL
     m1 <- p1 # mean, observed
     z1 <- (m1 - p0)/sqrt(p0 * (1 - p0)/n1)
     pv1 <- 1 - pnorm(z1,lower.tail=TRUE) + pnorm(z1,lower.tail=FALSE)
     perc <- (1-((1-conf.level)/2))
     lower <- p1 - qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     upper <- p1 + qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     ci <- c(lower, upper)
     print(c("z-statistic:",z1))
     print(c("p-value:",pv1))
     print(c("ci (lower,upper):",ci))
    }
    if(alternative=="less"){
     x2 <- NULL
     m1 <- p1 # mean, observed
     z1 <- (m1 - p0)/sqrt(p0 * (1 - p0)/n1)
     pv1 <- pnorm(z1, lower.tail = TRUE)
     perc <- (1-((1-conf.level)/2))
     lower <- p1 - qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     upper <- p1 + qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     ci <- c(lower, upper)
     print(c("z-statistic:",z1))
     print(c("p-value:",pv1))
     print(c("ci (lower,upper):",ci))
    }
    if(alternative=="greater"){
     x2 <- NULL
     m1 <- p1 # mean, observed
     z1 <- (m1 - p0)/sqrt(p0 * (1 - p0)/n1)
     pv1 <- pnorm(z1, lower.tail = FALSE)
     perc <- (1-((1-conf.level)/2))
     lower <- p1 - qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     upper <- p1 + qnorm(perc) * sqrt(p1 * (1 - p1)/n1)
     ci <- c(lower, upper)
     print(c("z-statistic:",z1))
     print(c("p-value:",pv1))
     print(c("ci (lower,upper):",ci))
    }
    } #closes the else for having p2 & n2
  } #final closing mark


Z.prop.test(p1 = 0.6, p0=0.8, n1=30, p2 = NULL, n2 = NULL, alternative = "greater", conf.level=0.95)

x1 <- c(0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 
    1, 1, 0, 1, 0, 1, 1)
mean(x1)
length(x1)

#x1 <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 0,1, 1, 1, 1, 1, 1, 1, 1, 1, 0,1, 1, 1, 1, 1, 1, 1, 1, 1, 0)

pt <- prop.test(x = sum(x1), n = length(x1), p = 0.8, conf.level = 0.95, correct = FALSE, 
    alternative = "greater")
pt
```

# Challenges

1. Couldn't get through this hw the first time I tried it :(

2. I still don't fully understand the p x n > 5 rule of thumb, is this for every proportion that you have or just pi (p0; the expected population proportion). I did n x p for all the combinations (p0 x n1, p1 x n1, p2 x n2) just to be safe. I'm confused about using the same 'n1' for both p0 & p1 - is that the right thing to do or no?

3. I'm sure there's a prettier way to print the function output than the way I did it haha. 

4. 


